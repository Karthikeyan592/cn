(((Framing)
Server.py----------------------------------------------------------------------
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 23 11:40:31 2022

@author: 20pw17
"""

import socket

s=socket.socket()
host = socket.gethostname()
port=12345

s.bind((host, port))
s.listen(5)

while True:
    c, addr = s.accept()
    print('Got connection from',addr)
    while True:
        
        bs = c.recv(1024).decode()
        print(bs)
        
        for i in bs.split():
            if '111110' in i:
                bs=bs.replace('111110','11111')

        uts=''
        for i in bs.split():
            if i=='10100011':
                uts+='ESC '
            elif i=='01111110':
                uts+='FLAG '
            else:
                uts+=chr(int(i,2))+' '
        
        
        uts=uts.replace('ESC FLAG','FLAG')
        uts=uts.replace('ESC ESC','ESC')
        uts=uts.strip(' ')
        
        print(uts)
        k="Done"
        c.send(k.encode())
        break
    
s.close()        

----------------------------------------------------------------------------------------------------------------

client.py------------------------------------------------------------------------------------------------------

# -*- coding: utf-8 -*-
"""
Created on Wed Mar 23 11:32:42 2022

@author: 20pw17
"""
import socket

c=socket.socket()
host=socket.gethostname()
port=12345

print(host)
        
c.connect((host,port))
while(1):
    s=input()
    ss=''
    for i in s.split(' '):
        if i=='ESC':
            ss+='ESC ESC ' 
        elif i=='FLAG':
            ss+='ESC FLAG '
        else:
            ss+=i+' '
    bs=''
    for i in ss.split():
        if i=='ESC':
            bs+='10100011 '
        elif i=='FLAG':
            bs+='01111110 '
        elif ord(i)>=65 and ord(i)<=90:
            #print(bin(ord(i))[2:])
            bs+=format(int(bin(ord(i))[2:]),'#0008')+' '
            
    bs=bs.strip(' ')
    print(bs)
    for i in bs.split():
        
        if '11111' in i:
            #print(i)
            bs=bs.replace('11111','111110')
            
    print(bs)
    
    c.send(bs.encode())
    s_msg=c.recv(1024).decode()
    print(s_msg)
    if(s_msg=="Done"):
        print("Connection end")
        break
c.close()
    
-------------------------------------------------------------------------------------------------------------

((((Hamming code))

def calcRedundantBits(m):

	for i in range(m):
		if(2**i >= m + i + 1):
			return i


def posRedundantBits(data, r):

	j = 0
	k = 1
	m = len(data)
	res = ''

	for i in range(1, m + r+1):
		if(i == 2**j):
			res = res + '0'
			j += 1
		else:
			res = res + data[-1 * k]
			k += 1

	# counted backwards. (m + r+1 ... 1)
	return res[::-1]


def calcParityBits(arr, r):
	n = len(arr)


	for i in range(r):
		val = 0
		for j in range(1, n + 1):


			if(j & (2**i) == (2**i)):
				val = val ^ int(arr[-1 * j])
				# -1 * j is given since array is reversed

		arr = arr[:n-(2**i)] + str(val) + arr[n-(2**i)+1:]
	return arr


def detectError(arr, nr):
	n = len(arr)
	res = 0


	for i in range(nr):
		val = 0
		for j in range(1, n + 1):
			if(j & (2**i) == (2**i)):
				val = val ^ int(arr[-1 * j])



		res = res + val*(10**i)

	return int(str(res), 2)


data = '1011001'


m = len(data)
r = calcRedundantBits(m)


arr = posRedundantBits(data, r)


arr = calcParityBits(arr, r)


print("Data transferred is " + arr)

arr = '11101001110'
print("Error Data is " + arr)
correction = detectError(arr, r)
print("The position of error is " + str(correction))
----------------------------------------------------------------------------------------
(((CRC CODE)

class CRC:
	
	def __init__(self):
		self.cdw = ''

	def xor(self,a,b):
		result = []
		for i in range(1,len(b)):
			if a[i] == b[i]:
				result.append('0')
			else:
				result.append('1')


		return  ''.join(result)



	def crc(self,message, key):
		pick = len(key)

		tmp = message[:pick]

		while pick < len(message):
			if tmp[0] == '1':
				tmp = self.xor(key,tmp)+message[pick]
			else:
				tmp = self.xor('0'*pick,tmp) + message[pick]

			pick+=1

		if tmp[0] == "1":
			tmp = self.xor(key,tmp)
		else:
			tmp = self.xor('0'*pick,tmp)

		checkword = tmp
		return checkword

	def encodedData(self,data,key):
		l_key = len(key)
		append_data = data + '0'*(l_key-1)
		remainder = self.crc(append_data,key)
		codeword = data+remainder
		self.cdw += codeword
		print("Remainder: " ,remainder)
		print("Data: " ,codeword)

	def reciverSide(self,key,data):
		r = self.crc(data,key)
		size = len(key)
		print(r)
		if r == size*0:
			print("No Error")
		else:
			print("Error")



data = '1001'
key = '1101'
c = CRC()
c.encodedData(data,key)
print('---------------')
c.reciverSide(c.cdw,key)
print('---------------')
print(c.cdw)

-----------------------------------------------------------------------------------------

(((Multi-thread))

import socket
import threading

serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
print("Server socket created")

serverSocket.bind(('localhost', 12345))


def handle_client():
    connected = True

    thisdict = {

        "Rahul": 10000,
    }
    while connected:

        msge, addr = serverSocket.recvfrom(1024)
        print(addr)
        req=msge[0].decode()
        Cip=msge[1]
        print("server is connected with : ",Cip)
        
        m = msge.decode()
        print("Message from Client"+m)
        if m== "new":
            msge, addr = serverSocket.recvfrom(1024)
            name = msge.decode()
            thisdict[name] = 0

        elif m == "existing":

            msge, addr = serverSocket.recvfrom(1024)
            name = msge.decode()
            print("Name: " + name)
            print(thisdict[name])
            msge, addr = serverSocket.recvfrom(1024)
            r = msge.decode()
            print("R: " +r)

            ad = "Hello world"
            serverSocket.sendto((ad).encode(), ('localhost', 12345))

            if r=="d":
                msge, addr = serverSocket.recvfrom(1024)
                amt = msge.decode()
                thisdict[name]=thisdict[name]+amt
            elif r=="w":
                msge, addr = serverSocket.recvfrom(1024)
                amt = msge.decode()
                thisdict[name] = thisdict[name] - amt
            elif r=="b":
                serverSocket.sendto(bytes(str(thisdict[name]),"utf-8"),Cip)



def start():
    while (True):
        thread = threading.Thread(target=handle_client())
        thread.start()


start()

------------------------------------------------------------------------------------------------------------------------------------


import socket

clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
op = "Y";
while op == 'Y' or op == 'y':

    msg = input("New user (new) OR Existing user (existing)?")
    clientSocket.sendto((msg).encode(), ('localhost', 12345))
    

    if msg == "new":
        name = input("Enter your name:")
        clientSocket.sendto((name).encode(), ('localhost', 12345))

    if msg == "existing":
        name = input("Enter your name:")
        clientSocket.sendto((name).encode(), ('localhost', 12345))
        print("Got name")
        r = input("Withdraw(w) or Deposit(d) or Balance(b)")
        clientSocket.sendto((r).encode(), ('localhost', 12345))
        print("Got r")


        if r=="w" or r=="d":
            amt = input("Enter the amount:")
            clientSocket.sendto((amt).encode(), ('localhost', 12345))

        elif r=="b":
            servermsg = clientSocket.recvfrom(1024)
print(servermsg[0].decode())

        op = input("To end (n) , To continue(y) : ")

----------------------------------------------------------------------------------------

((((UDP ))

from socket import *
import sys
import select

host=&quot;0.0.0.0&quot;
port = 9999
s = socket(AF_INET,SOCK_DGRAM)
s.bind((host,port))

addr = (host,port)
buf=1024

f = open(&quot;file.pdf&quot;,&#39;wb&#39;)

data,addr = s.recvfrom(buf)
try:
while(data):
f.write(data)
s.settimeout(2)
data,addr = s.recvfrom(buf)
except timeout:
f.close()
s.close()
print &quot;File Donwloaded
#!/usr/bin/env python

from socket import *
import sys

s = socket(AF_INET,SOCK_DGRAM)
host =sys.argv[1]
port = 9999
buf =1024
addr = (host,port)

file_name=sys.argv[2]

f=open(file_name,&quot;rb&quot;)
data = f.read(buf)

s.sendto(file_name,addr)
s.sendto(data,addr)
while (data):
if(s.sendto(data,addr)):
print &quot;sending ...&quot;
data = f.read(buf)
s.close()
f.close()

--------------------------------------------------------------------------------

(((Stop and wait))

Reciever--
import socket
import random
from ast import literal_eval


#------------------------------------------------------------------------
#create socket object and bind it.
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host ="localhost"
port =8000
s.connect((host,port))

#------------------------------------------------------------------------

#take input from user 
p_noack = float(input("enter probability of acknowledgement not being sent"))
count = 0 


def try_ack(previous, current):
    if abs(previous-current) == 1:
        return True
    else:
        return False 

l = []
for i in range(0,1000):
    l = l +[i]
output = ""
   
while 2: 
    data=s.recv(8).decode()
    print("Received --> "+data)
    datadict = literal_eval(data)
    index = list((datadict).keys())[0]
    number= random.randint(0,1000)
    if count == 0:
        count = count +1
        current = index
        previous = 0
        if current == 0:
            previous = 1
    
    #simulating the acknowldgement message being lost on the way 
    else: 
        count = count +1
        previous = current
        current = index
        print ("p /c :", previous, current)
    if try_ack(previous, current):
        output  = output + list(datadict.values())[0]
        #print ("hello", l[number],p_noack*1000 )
        if l[number]<(p_noack*1000):
            print "Ack not sent"
            pass
        else:    
            str="Acknowledgement: Message Received"
            #print ("!!!!!!!!!")
            
            #print datadict.values()
            s.send(str.encode())
    else: 
        str="Acknowledgement: Message Received"
        s.send(str.encode())
        print ("indices did not match. Sending ack for previous element")
    print "the received bitstring is",output
  
s.close ()

Sender -- 

import socket
from threading import *
import time
import random



#------------------------------------------------------------------------
#create socket object and bind it.
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "localhost"
port = 8000
s.bind((host, port))

#------------------------------------------------------------------------
#defines the class for client. 
class client(Thread):
    #initialize everything
    def __init__(self, socket, address):
        Thread.__init__(self)
        self.sock = socket
        self.addr = address
        self.start()


    def run(self):

        while True:

            #take input from user 
            bitstring  = str(raw_input("enter bit string"))
            propogationtime = float(raw_input("enter propogation time"))
            p_nosend = float(input("enter probability of message getting lost:"))
            
            #create a list of 1000 elements. (redundant, can be changed)
            l = []
            for i in range(0,1000):
                l = l +[i]

            #go through all the bits of the bitstring. 
            i = 0
            while i < len(bitstring):
                #for each bit, create a dictionary with the current 
                #window index (i%2 => 0,1,0,1...) and the bit itself
                datadict = {}
                datadict = {i%2 : bitstring[i], }
                
                #convert the dictionary to a string 
                sendstring = str(datadict)
                
                #find a random number between 0,1000 (both included)
                number= random.randint(0,1000)
                
                #store current time 
                time1 = time.time()
                
                #if statement is true with a probability of (1-p_nosend)
                if l[number] < (p_nosend*1000):
                    #if true, send the bitstring.
                    clientsocket.send(sendstring)
                    #sleep to simulate the propogation time of the channel.
                    time.sleep((propogationtime)/1.1)
                    #after sleeping, record the current time. 
                    time2 = time.time()
                    #this flag indicates whether an acknowledgement has been received. 
                    ackflag= False
                
                #else statement is true with a probability of (p_nosend)
                #this simulates a packet being sent but getting lost
                #along the way (like our lives). 
                else: 
                    #imaginary send line here.
                    #wait for propogation time again. 
                    time.sleep(propogationtime/1.1)
                    #record current time 
                    time2 = time.time()
                    #for info of user:
                    print ("package dropped 1")
                    #set ack flag to False, again.  
                    ackflag= False               

                while True:
                    #if the time elapsed is less that prop time, 
                    if time2-time1<= propogationtime:
                        #store current time     
                        time2= time.time()

                        #set timeout to listen for an acknowledgement. 
                        clientsocket.settimeout(propogationtime/1.1)

                        #raises exception when the timeout occurs. 
                        try:
                            #attempt to listen for ack. 
                            recieved = clientsocket.recv(1024)
                            print(recieved)
                            
                            if recieved:
                                print "ack received"
                                i = i+1
                                ackflag = True
                                break 

                        #this occurs when listening has timed out. 
                        except:
                            #recheck if it has timed out (quite redundant):
                            if time2 - time1 >propogationtime and ackflag == False:
                                print ("timeout")

                                #at this stage, we again simulate a package drop 
                                #with prob p_nosend
                                number= random.randint(0,1000)

                                #package sent
                                if l[number] < (p_nosend*1000):
                                    clientsocket.send(sendstring)
                                    time1 = time.time()
                                    time2 = time.time()
                                    print "package sent"

                                #package dropped:    
                                else: 
                                    
                                    time1 = time.time()
                                    time2 = time.time()
                                    #time.sleep(propogationtime/1.1)
                                    
                                    print("package dropped 2")

                        
                    
                    
    
            

s.listen(5)
print ('Sender ready and is listening')
while (True):

    #to accept all incoming connections
    clientsocket, address = s.accept()
    print("Receiver "+str(address)+" connected")
    #create a different thread for every 
    #incoming connection 
    client(clientsocket, address)

-----------------------------------------------------------------------